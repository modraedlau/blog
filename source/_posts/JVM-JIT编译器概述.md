---
title: JVM JIT编译器概述
date: 2019-01-04 14:25:33
tags: JVM JIT
category: JVM
---

## 静态编译 vs 动态编译（AOT vs JIT）

### 静态编译
* 又称 "Ahead-Of-Time"(AOT) 编译
* 过程：源代码 -> 可执行码
* 大多数编译工作都在执行之前完成
* 可以利用复杂而繁重的分析和优化
  * 但是静态信息有时是不够的
  * 而且很难猜出实际的应用程序行为
* 无法利用特定平台功能，比如：SSE4.2 / AVX / AVX2，TSX，AES-NI，RdRand

### 动态编译（现代Java虚拟机使用动态编译）
* 又称 "Just-In-Time"(JIT) 编译
* 过程：源代码 -> 字节码 -> JIT编译后的可执行码
* 大多数编译工作都发生在应用程序执行期间
* 通过收集大量的数据进行Profiling，采用乐观的优化方式
  * 但是资源有限，并且需要与应用程序共享
* 因此：
  * 启动速度受到影响
  * 并且性能峰值也可能受损（但也不一定）

### Profiling
* 在执行期间收集有关代码的数据
  * 不变量
    * 类型，常量（比如空指针）
  * 统计数据
    * 分支，调用
* 收集到的数据可用于优化期
  * 有根据的猜测
  * 猜测可能是错的

### 乐观的编译器（Optimistic Compilers）
* 假设Profile是准确的
  * 根据Profile积极优化，如果发现错了就采取补救措施
* 并希望他们通常是正确的

### Profile引导优化（Profile-guided optimizations (PGO)）
* 使用Profile更有效的优化，JVM中的PGO：
  * 始终拥有他，默认打开
  * 开发人员（通常）对此不感兴趣或不关心
  * 分析结果始终和执行方案保持一致

### 乐观的编译器例子
```java
public void f() {
  A a;
  if (cond /* 始终为true */) {
    a = new B();
  } else {
    a = new C(); // 从未执行
  }
  a.m(); // A的确切类型是B或C？
}
```
优化：
```java
public void f() {
  A a;
  if (cond /* 始终为true */) {
    a = new B();
  } else {
    toInterpreter(); // 切换到解释器
  }
  a.m(); // A的确切类型是B
}
```

## (J)VM中的动态编译

### 动态编译（JIT）
* 可以在运行时进行非保守优化
* 将优化与产品交付周期分离
  * 更新JVM，运行相同的应用程序，实现更高的性能！
  * 可以”调整“目标平台
* 需要了解Java程序中的很多内容
  * 加载的类，执行的方法，profile
* 在此基础上进行优化
* 如果先前的假设是错误的，可能会重新优化










